<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="java基础基础数据类型long double 8字节 int flot 4字节 short char 2字节 Byte 1字节 Boolean 1位 String,Stringbuffer,Stringbuilder区别： String是不可变的，Stringbuffer和Stringbuilder是可变的 Stringbuffer是线程安全的，Stringbuilder是线程非安全的  相同处">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试题">
<meta property="og:url" content="http://1525.xyz/2020/08/20/java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Tom&#39;s Blog">
<meta property="og:description" content="java基础基础数据类型long double 8字节 int flot 4字节 short char 2字节 Byte 1字节 Boolean 1位 String,Stringbuffer,Stringbuilder区别： String是不可变的，Stringbuffer和Stringbuilder是可变的 Stringbuffer是线程安全的，Stringbuilder是线程非安全的  相同处">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-20T15:01:30.000Z">
<meta property="article:modified_time" content="2020-08-24T13:54:40.330Z">
<meta property="article:author" content="tom">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://1525.xyz/2020/08/20/java面试题/"/>





  <title>java面试题 | Tom's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tom's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://1525.xyz/2020/08/20/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-20T23:01:30+08:00">
                2020-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><h6 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h6><p>long double 8字节</p>
<p>int flot 4字节</p>
<p>short char 2字节</p>
<p>Byte 1字节</p>
<p>Boolean 1位</p>
<h6 id="String-Stringbuffer-Stringbuilder区别："><a href="#String-Stringbuffer-Stringbuilder区别：" class="headerlink" title="String,Stringbuffer,Stringbuilder区别："></a>String,Stringbuffer,Stringbuilder区别：</h6><ol>
<li>String是不可变的，Stringbuffer和Stringbuilder是可变的</li>
<li>Stringbuffer是线程安全的，Stringbuilder是线程非安全的</li>
</ol>
<p>相同处：三个类都是final类，不能被继承</p>
<h6 id="讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h6><p>这个通过类加载机制能说清楚，在类加载的时候会先为静态变量赋值，这个时候如果静态变量的值来自于一个静态方法，则会调用这个方法，同样，在类加载中，父类会先加载，</p>
<p>p属性涉及的方法<br>p的静态代码块<br>son属性涉及的方法<br>son的静态代码块<br>p的构造代码块<br>p的构造函数<br>son的构造代码块<br>son的构造方法</p>
<h6 id="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><a href="#抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。" class="headerlink" title="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。"></a>抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</h6><p>抽象类访问限定符可用有protected，而interface不可用</p>
<p>抽象类中可用定义成员属性，构造方法，而interface不可以</p>
<p>接口可以继承多个接口，但是抽象类不能继承多个类</p>
<p>类可以实现多个接口</p>
<h4 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h4><h4 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h4><h5 id="请谈谈你对java集合的理解"><a href="#请谈谈你对java集合的理解" class="headerlink" title="请谈谈你对java集合的理解"></a>请谈谈你对java集合的理解</h5><p>java集合主要分为两种，在顶层主要有两个接口，一个是collection，一个是map，在collection下面有3个接口，分别是set,list,queque。另外一个顶层接口是map。常用的集合有arrylist,linkedlist,hashmap,hashset.</p>
<h5 id="请谈下arraylist和Linkedlist的区别"><a href="#请谈下arraylist和Linkedlist的区别" class="headerlink" title="请谈下arraylist和Linkedlist的区别"></a>请谈下arraylist和Linkedlist的区别</h5><p>arraylist的话他底层是用数组实现的，具有随机访问数据快的优点，但是确定删除和插入元素的效率减低，而linkedlist的底层是通过链表来实现的，这样的优点是不用一次性分配一个连续的内存快，同时删除插入效率高，缺点就是随机访问能力差</p>
<h5 id="请谈下arraylist的扩容机制"><a href="#请谈下arraylist的扩容机制" class="headerlink" title="请谈下arraylist的扩容机制"></a>请谈下arraylist的扩容机制</h5><p>arraylist默认初始化底层数组为空，只有当发起一个add操作时才会创建一个长度为10的数组，在add的同时会去判断容量够不够用，如果不够用了，就会扩容成原来的1.5倍</p>
<h5 id="请谈下hashmap"><a href="#请谈下hashmap" class="headerlink" title="请谈下hashmap"></a>请谈下hashmap</h5><p>hashmap分为jdk1.8之后和jdk1.8之前，在jdk1.8之前，hashmap的实现是由数组和链表实现的，如果发生碰撞，则通过头插法插入到链表中，但是1.7的hashmap由于使用头插法时在并发环境中可能会出现死锁的情况，并且，如果碰撞严重，hashmap可能会退化为一个链表，这样效率就会很低，因此在1.8之后，hashmap换成了数组加链表加红黑树的实现，具体为初始化hashmap的大小是16，然后插入时，发生碰撞，放入链表，如果链表的长度超过了预定值（8）的话，就会将此链表转为红黑树，同时，如果hashmap元素的个数超过了容量的0.75倍，hashmap会发生扩容，具体扩容成原来的2倍。</p>
<p>关键点：</p>
<ol>
<li>loadFactor,加载因子，默认是0.75</li>
<li>默认初始化容量是16</li>
<li>默认树化的阈值是8，前提是桶的长度超过了64</li>
<li>默认去树化的阈值是6</li>
<li>调用无参构造是并没有创建桶，在put时回去创建</li>
<li>hashmap会对key的hahcode进行二次hash，具体方法是原有的hashcode无符号右移16位亦或上原来的hashcode</li>
<li>确定一个entry放入到哪个桶里面是通过桶的长度减一和hashcode相与</li>
<li>hashmap会保证桶的长度是2的n次方（通过tableSizeFor(n)来实现的，找一个距离n最近的2的n次方）</li>
<li>jdk8在resize时，采用的是尾插法</li>
</ol>
<h6 id="Hashmap在jdk1-8中的resize不需要重新hash原因"><a href="#Hashmap在jdk1-8中的resize不需要重新hash原因" class="headerlink" title="Hashmap在jdk1.8中的resize不需要重新hash原因"></a>Hashmap在jdk1.8中的resize不需要重新hash原因</h6><p>这个是因为hashmap在1.8后。优化了计算index的算法，通过hashcode&amp;(n-1)来实现，其中n是2的次方，那在扩容的时候将table的长度n扩展成2n（相当于向左移一位），此时table的长度n也是2的次方，在-1后得到的二进制全部为1，这个时候在来进行&amp;运算，则只需判断新加的哪一位bit是0还是1，如果是0则原来的index不表，如果是1，则index变成原来index+oldcap(原有索引加上原来的容量)</p>
<h6 id="插入流程："><a href="#插入流程：" class="headerlink" title="插入流程："></a>插入流程：</h6><p>先判断table是不是为空，或者table的lenth==0,如果是0，掉一次table的resize方法。计算出应该放在哪个桶里面，如果桶为空，则直接放入，如果桶有数据，则判断桶的key的hashcode和equals是否一致，如果是一致，就替换桶内元素，如果不一致，就判断当前桶是不是红黑树，如果是红黑树，就调用红黑树插入的方法，如果不是，则遍历桶中的链表，看是否是一样的key,如果一样，则替换，不一样就插入，插入是会判断插入后会不会超过链表的长度是否会超过树化的阈值，如果超过了，就调用进行树化，在树化里面会判断当前桶的table长度有没有超过64，如果没有超过64就调用一次扩容</p>
<p>当</p>
<h6 id="resize方法具体是咋样的"><a href="#resize方法具体是咋样的" class="headerlink" title="resize方法具体是咋样的"></a>resize方法具体是咋样的</h6><h6 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h6><ul>
<li><p>hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？</p>
<p>通过拉链发，链表以及红黑树，转成红黑树的原有是在碰撞激烈的情况下，hashmap可能会变成一个链表</p>
</li>
<li><p>hashmap什么时候会触发扩容？</p>
<p>在hashmap中的元素大于threshold时（threshold=loadFactor(0.75)*capacity(容量)）</p>
</li>
<li><p>jdk1.8之前并发操作hashmap时为什么会有死循环的问题？</p>
</li>
</ul>
<ul>
<li><p>hashmap扩容时每个entry需要再计算一次hash吗？</p>
<p>1.8之前需要，1.8后不需要</p>
</li>
<li><p>hashmap的数组长度为什么要保证是2的幂？</p>
<p>参考：Hashmap在jdk1.8中的resize不需要重新hash原因</p>
</li>
<li><p>如何用LinkedHashMap实现LRU？</p>
</li>
<li><p>如何用TreeMap实现一致性hash？</p>
</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="请谈下线程和进程的区别"><a href="#请谈下线程和进程的区别" class="headerlink" title="请谈下线程和进程的区别"></a>请谈下线程和进程的区别</h5><p>进程是操作系统分配资源的最小单位，而线程是共享进程的资源，是在进程内部执行</p>
<h5 id="请谈下java线程的几种状态"><a href="#请谈下java线程的几种状态" class="headerlink" title="请谈下java线程的几种状态"></a>请谈下java线程的几种状态</h5><p>java线程的状态有new,runnable,blocked,waiting,timed wating,teminated</p>
<ol>
<li>创建一个线程时（new Thread）状态是new,调用线程的start()方法，线程会进入runnable状态（包括了ready(就绪状态)和running(运行中)，如果调用了yield()方法，线程进入ready状态，如果系统调度了则进入running状态）</li>
<li>当调用了Thread.sleep(long),Object.wait(long),Thread.join(long),LockSupport.parkNanos(),LockSupport.parkUntil()时进入timed wating状态，等待时间结束，进入就绪状态。（也可通过下面的唤醒方法唤醒）</li>
<li>当调用了Object.wait(),Thread.join(),LockSupport.park()则进入waiting状态，只有其他线程调用了Object.notify(),Object.notifyAll(),LockSupport.unpark()后，线程才会进入到就绪状态。</li>
<li>等待进入synchronized方法，或者synchronized代码块时，线程进入blocked状态,线程获取到锁后进入到就绪状态。</li>
<li>线程执行完毕，进入到teminated状态。</li>
</ol>
<h5 id="请谈下java锁升级的过程"><a href="#请谈下java锁升级的过程" class="headerlink" title="请谈下java锁升级的过程"></a>请谈下java锁升级的过程</h5><p>java对象在堆中主要有：(1)对象头(2)实例数据(3)填充数据组成</p>
<p>对象头又分为：(1)markword(存储对象的hashcode,gc分代年龄，锁状态等息息)（2）类型指针（3）如果是数组，则还会存放一个数组的长度</p>
<p>Markwordz状态：</p>
<table>
<thead>
<tr>
<th></th>
<th>偏向锁标记</th>
<th>锁标记</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td></td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td></td>
<td>10</td>
</tr>
</tbody></table>
<p>java中锁升级是指的synchronized锁从无锁，偏向锁，轻量级锁，重量级锁升级的过程，java中锁只能升级，而不能降级。</p>
<ol>
<li><p>重量级锁是指的依赖系统的同步函数的锁，这些同步函数都会涉及到用户态和内核状态的切换，线程的上下文切换，成本较高。这就会导致在没有偏向锁和轻量级锁的情况下单一线程或者两个线程近乎于交替执行synchronized代码块或者方法时，效率较低（jdk1.6之前存在的问题）。重量级锁的实现依赖monitor对象，在monitor对象中维护了Contentionlist（争抢list），EntryList(进入等待执行的list)，waitSet(等待队列)。当一个线程尝试获取一把锁时，如果该锁知被占有的状态，该线程会被封装成一个ObjectWaiter放入到ContentionList中并暂停当前线程，在持有锁的线程释放锁之前，在ContentionList中的所有元素会被放入到EntyList中去，并唤醒EntryList中队首的线程。当一个线程调用Object.wait()方法时，线程对于的ObjectWaiter会被放入到WaitSet中，然后释放锁，在wait的线程被唤醒时，对应的ObjectWaiter会被放入到EntrySet中。</p>
</li>
<li><p>轻量级锁时为了避免在线程<strong>交替执行</strong>同步代码时使用重量级所带来的性能消耗，实现原理是在一个线程执行同步代码块时，在线程的栈帧中创建一个内存区域（Displaced Mark Word）用于存放锁对象头中的Mark Word,将锁对象头中的Mark Word复杂到栈帧中后，尝试使用cas去将自己的Displaced Mark Word的地址存到锁对象的Mark Word中，如果成功，则获取锁成功，如果失败，自旋，多次自旋不成功膨胀为重量级锁</p>
</li>
<li><p>偏向锁指的是偏向某一线程的锁，其意义是避免在没有多线程竞争的情况下（执行同步代码）使用轻量级锁带来的轻量级锁上锁解锁的性能损耗，偏向锁只有在上锁的过程中有一次cas操作，后续只需要一次判断当前线程是否为持有锁的线程。偏向锁通过在锁对象的markword中存放持有锁的线程的threadId来实现。</p>
<h6 id="升级过程："><a href="#升级过程：" class="headerlink" title="升级过程："></a>升级过程：</h6><ol>
<li>偏向锁升级轻量级锁：当一个线程尝试获取锁对象时，会通过cas将自己的线程号放入到锁对象的markword中去，偏向锁不会主动释放锁，所以下次该线程在一次获取锁时，只需要判断一下当前锁对象中存放的线程号是否是自己的。如果一致，就获取锁成功，如果不一致，说明发生竞争，已经被其他线程占有，这时先去查看持有锁的那个线程是否存活，如果不存活，则将锁对象的状态改成无锁，通过cas去获取锁。如果存活就查看该线程的栈帧信息，如果还需要持有这个锁，就暂停持有锁的线程的执行，进行锁升级。如果不需要只有这个锁，将该锁对象的状态改成无锁，通过cas去获取锁。</li>
<li>轻量级锁升级重量级锁：轻量级锁加锁时会将锁对象的markword拷贝一份放入当前线程的栈帧中（displayed markword），拷贝完成后会通过cas去将自己栈帧中的displayed markword的地址修改到锁对象的markword中，如果cas成功，则说明获取锁成功，如果cas失败，比如在拷贝markword的过程中，另外一个线程以及将锁获取到了，则当前线程进入自旋状态（自旋锁），但是一直自旋下去也不行，自旋次数过多则升级成重量级锁。</li>
</ol>
</li>
</ol>
<h5 id="请谈谈你对volatile的理解"><a href="#请谈谈你对volatile的理解" class="headerlink" title="请谈谈你对volatile的理解"></a>请谈谈你对volatile的理解</h5><p>volatile主要保证的是可见性和防止指令重排序</p>
<p>可见性的问题要从java的内存模型来说起，java中，线程有各自的私有内存，还有一个共享的主内存，如果ab两个线程同时需要访问变量x,当一个线程a修改一个变量x时，会先去主内存中将变量x拷贝到自己的私有内存中，修改完了在刷新回去，此时b去读变量x时只会去读自己私有内存中的数据，这个时候数据以及发生变化了，这样就会导致数据的不一致，这个时候就需要使用volatile，被volatile修饰的变量读取时需去主内存中读取回来，这样就保证了可见性问题。</p>
<p>指令重排应该是通过内存屏障来实现的，具体还没深入了解，最常见的应用就是单例模式中的dcl,使用volatile修饰单例,主要是在new的过程可能被重排，比如先分配了内存，再将应用指向该内存，最后在调用构造函数，如果在第二步的时候有其他线程进来获取该单例，则调用时会发现该对象没有初始化。</p>
<h5 id="lock解决了哪些synchronized不能解决的问题"><a href="#lock解决了哪些synchronized不能解决的问题" class="headerlink" title="lock解决了哪些synchronized不能解决的问题"></a>lock解决了哪些synchronized不能解决的问题</h5><ol>
<li>lock有可尝试锁的功能（lock.tryLock(),lock.tryLock(long,TimeUnit)）</li>
<li>lock.lockInterruptibly()可中断的等待锁</li>
<li>lock.newCondition()条件锁，分情况处理，对线程分组，生产者是一个condition,消费者是一个condition，唤醒的时候可以指定唤醒一个condition的，等待的时候也是</li>
<li>ReentrantLock提供了公平锁和非公平锁</li>
<li>ReentrantReadWriteLock读写分离锁</li>
<li>lock需要手动的释放锁，一般由try,finally来实现</li>
<li>lock可以知晓自己有没有成功获取锁（通过tryLock()实现）</li>
</ol>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>线程池的关键参数：coreSize,maxSize,keepLiveTime,TimeUnit,workQueue,handler</p>
<p>逻辑：当有一个新任务加进来的时候，会先判断coreSize是否满了，如果没满，则执行任务，如果满了，则判断workQueue是否满了，如果没满，则放入workQueue中，如果满了，则判断是否已到最大线程数，如果没到，则新建线程执行任务，如果到了，则调用handler进行处理。</p>
<h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><h5 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h5><p>索引的定义：一种帮助快速检索数据的数据结构。</p>
<p>优点：</p>
<ol>
<li>减少查询需要扫描的数据量</li>
<li>减少服务器排序和创建临时表的操作（加快group by和order by等操作）</li>
<li>将随机io变为顺序io（加快查询速度）</li>
</ol>
<p>缺点：</p>
<ol>
<li>首先，索引也是数据，需要占用额外的存储空间，其实在插入，删除，更新的过程中，需要维护索引，带来额外的时间开销</li>
</ol>
<p>数据结构上分为：</p>
<ol>
<li>b+树索引</li>
<li>hash索引</li>
<li>FullText索引</li>
<li>R-tree索引</li>
</ol>
<p>物理存储结构上：</p>
<ol>
<li><p>聚集索引：不是一种索类型，而是存储数据的方式，在数据中保存了索引和数据，在innodb中默认使用主键进程聚集索引，在删除插入更新后，需要重新维护数据的顺序，所有在其他索引中并不是放的该数据的物理地址，而是该数据的主键。</p>
</li>
<li><p>非聚集索引</p>
</li>
<li><p>逻辑角度：</p>
<ol>
<li>主键索引</li>
<li>普通索引（单列索引）</li>
<li>多列索引（复合索引）</li>
<li>唯一索引和非唯一索引</li>
</ol>
</li>
</ol>
<p>索引覆盖：索引覆盖是指的查询的数据在索引存储的数据中是有的，如select name ,age from stu where name =’tom’,在stu表中，name和age是一个聚合索引，那在通过name查询时，找到的数据中会存储了主键和name,以及age，则满足了查询需求，不需要回表，这个就是索引覆盖。</p>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><ol>
<li>添加查询调节，避免全表扫描</li>
<li>where条件最好加一个非空判断</li>
<li>记录避免使用!=或&lt;&gt;来放索引</li>
<li>避免使用or,in,not in</li>
<li>索引的重要性</li>
</ol>
<h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><p>数据库中的JOIN称为连接，连接的主要作用是根据两个或多个表中的列之间的关系</p>
<p>连接分为以下4类：</p>
<ol>
<li>内连接:内连接就是求两个表的交集，从笛卡尔积的角度讲就是从笛卡尔积中选出<strong>满足某条件</strong>的记录,内连接在SQL中是<code>JOIN</code>|<code>INNER JOIN</code>; <code>INNER JOIN</code> 与 <code>JOIN</code> 的查询结果都是相同的，也就是说两个的作用都是一样的。内连接查询返回两个表中在<code>ON</code>后面指定的列条件相同时的行;</li>
<li>外连接：外连接分为 <strong>左外连接</strong><code>LEFT JOIN</code> 和 <strong>右外连接</strong><code>RIGHT JOIN</code>。虽然是两种写法，但他们之间是可以转换的，其实是互相的变型，如select * from a left join b==select *from b right join a ，返回a表中的所有数据加上b表中符合on条件的数据，如果a表中的数据在b表中没有对应的，则用null填充</li>
<li>全连接</li>
<li>笛卡尔集:每条记录与表2中的每一条记录拼成数据对</li>
</ol>
<h4 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h4><h5 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h5><p>实例化bean，填充属性，调用BeanNameAware.setBeanName()方法，调用BeanFacotryAware.setBeanFacotry(),调用ApplicationAware.setApplicationAware()方法，调用BeanPostProcessor.postProcessBeforeInitialization(),调用InitializingBean.afterPropertiesSet()方法，调用init-method,调用BeanPostProcessor.postProcessAfterInitialization()</p>
<p>总结来说：</p>
<ol>
<li>调用构造方法</li>
<li>设置属性</li>
<li>调用实现了的Aware接口的方法</li>
<li>调用BeanPostProcessor的PostProcessorBeforeInitialization()</li>
<li>调用@PostConstruct注解的方法</li>
<li>调用实现InitializingBean的afterPropertiesSet()方法</li>
<li>调用bean配置上的initMethod（xml对应的是init-method）</li>
<li>调用BeanPostProcessor的postProcessAfterInitialization()</li>
<li>调用@PreDestroy注解的方法</li>
<li>调用DisposableBean.destroy()方法</li>
<li>调用bean配置上的destroyMethod（xml对应的是destroy-method）</li>
</ol>
<p>记忆来说，就记前7就行了，后面的4个顺序和4-7的一致。</p>
<h5 id="ioc-aop讲一下"><a href="#ioc-aop讲一下" class="headerlink" title="ioc,aop讲一下"></a>ioc,aop讲一下</h5><p>Ioc:依赖注入，工厂模式</p>
<p>Aop:面向切面编程，代理模式</p>
<p>ioc:在传统开发中，调用者需要被调用者提供服务时，是由调用者来创建被调用者的实例，在spring中，实例的创建由springl来完成，并且注入给需要的调用者（依赖注入），依赖注入和控制翻转是一个概念。</p>
<p>Aop: aop是面向切面编程，是从另外一个角度来考虑程序的结构，把与核心业务无关的功能抽出来，按需的切入需要的地方，常用在日志收集，权限认证。</p>
<p>aop术语：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Joinpoint(连接点)</td>
<td>指那些被拦截到的点，在Spring中，可以被动态代理拦截目标类的方法</td>
</tr>
<tr>
<td>Pointcut(切入点)</td>
<td>指要对哪些Joinpoint进行拦截，即被拦截的连接点</td>
</tr>
<tr>
<td>Advice(通知)</td>
<td>指拦截到Joinpoint之后要做的事情，即对切入点增强的内容</td>
</tr>
<tr>
<td>Target(目标)</td>
<td>指代理的目标对象</td>
</tr>
<tr>
<td>Weaving(植入)</td>
<td>指把增强代码应用到目标上，生成代理对象的过程</td>
</tr>
<tr>
<td>Proxy(代理)</td>
<td>指生成的代理对象</td>
</tr>
<tr>
<td>Aspect(切面)</td>
<td>切入点和通知的结合</td>
</tr>
</tbody></table>
<h5 id="spring事务的传播性"><a href="#spring事务的传播性" class="headerlink" title="spring事务的传播性"></a>spring事务的传播性</h5><p>spring中事务的传播有以下7种：</p>
<p>可以按支持当前事务来划分为3种：</p>
<ol>
<li>支持当前事务<ol>
<li>PROPAGATION_REQUIRED：如果当前存在事务，则加入当前事务，如果当前没有事务，就新建一个事务执行</li>
<li>PROPAGATION_SUPPORTS：如果当前存在事务，则加入当前事务，如果当前没有事务，就按非事务的方式执行</li>
<li>PROPAGATION_MANDATORY：如果当前存在事务，则加入当前事务，如果当前没有事务，则抛出异常</li>
</ol>
</li>
<li>不支持当前事务：<ol>
<li>PROPAGATION_REQUIRES_NEW：新建一个事务，如果当前有事务，则将当前事务挂起，执行完毕后恢复当前事务</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务的方式执行，如果当前存在事务，则挂起当前事务，执行完毕后恢复当前事务</li>
<li>PROPAGATION_NEVER：以非事务的方式执行，如果当前存在事务，则抛出异常</li>
</ol>
</li>
<li>其他情况：<ol>
<li>PROPAGATION_NESTED：如果当前存在事务，则挂起当前事务，新建一个事务执行，执行完毕后恢复当前事务，如果当前没有事务，则新建一个事务执行（类似PROPAGATION_REQUIRED）</li>
</ol>
</li>
</ol>
<h5 id="三级缓存："><a href="#三级缓存：" class="headerlink" title="三级缓存："></a>三级缓存：</h5><p>spring创建bean时优惠3步，1创建实例，2填充属性，3调用init方法</p>
<p>如：创建bean A时，先调用构造方法创建A的实例，并将A放入到singleFacotries里面去提前曝光，在填充属性时，发现A依赖了B则会去创建B，创建B时发现又发现B又依赖A，则B会去一级缓存二级缓存中查找，由于A还在创建过程中，所有在一二级缓存中是没有的，于是在去三级缓存中查询，由于A提前曝光了自己，所以在三级缓存中能拿到A，B拿到A后将三级缓存中的A删除，并放入到二级缓存中，这个时候B创建完毕，将B放入到一级缓存中，回到A，A就有了B，然后A进行剩下的填充数据和调用init方法，最后A创建完毕，放入到一级缓存中。</p>
<h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#和$的区别"></a>#和$的区别</h5><p>#传递的参数会进行编译，有效的防止sql注入，$是将参数替换到语句中，不能防止sql注入，是一种较危险的操作</p>
<h5 id="mybatis的缓存"><a href="#mybatis的缓存" class="headerlink" title="mybatis的缓存"></a>mybatis的缓存</h5><p>一级缓存：存在于session中，在一个会话中有效，在同一个会话中修改了数据，会导致缓存失效，但是不是在同一个会话中修改的数据，不会导致缓存失效，会导致数据的脏读。</p>
<p>二级缓存：存在于namepace中，应用于在多个session之间需要共享缓存，二级缓存是通过将executor装饰城cachingExecutor来实现的，会先查二级缓存，二级缓存没有查一级缓存，一级缓存没有再查数据库，在一个session查询没有提交事务是，缓存是没有生效的，同一个namespace下的一个session修改了数据，会导致二级缓存失效，多表查询会出现脏数据，</p>
<ol>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h5 id="mybatis实现分页的方式"><a href="#mybatis实现分页的方式" class="headerlink" title="mybatis实现分页的方式"></a>mybatis实现分页的方式</h5><ol>
<li>通过limit来实现</li>
<li>通过pagehelper来实现</li>
<li>通过intercepter来实现</li>
</ol>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><h5 id="cap定理"><a href="#cap定理" class="headerlink" title="cap定理"></a>cap定理</h5><p>指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。（实际上是为了p,必须在a和c之前作出选择，实际情况下，分区很少情况出问题，所以大部分时间都是能满足cap的）p就是原罪。</p>
<ol>
<li>C  Consistency（一致性) 客户端从集群中的节点a获取到的数据应该是和从节点b获取的数据是一致的</li>
<li>A Availability（可用性）只要收到的客户端的请求，服务就必须给出响应</li>
<li>P Partition（分区容错性）是集群可能部署在不通过的网络分区中，两个分区之间的通信可能出现不可用的情况（这种情况是不能避免的）</li>
</ol>
<p>原因：由于p这种情况是不可避免的，所以a,c只能满足到一点，具体来说就是，要保证集群的一致性，就需要有集群中的节点能够同步数据，如果出现了分区出错，不能同步数据，这个时候，集群就不能提供服务，锁定集群提供服务的能力，等到数据同步之后才能继续提供服务，要保证可用性，则必须响应客户端的请求，在出现了分区网络问题的时候，数据不能同步，但是由于需要保证集群的可用性，并没有锁定服务进行数据同步，这就导致了一致性的丢失。</p>
<p>eg:erueka是ap，提供高可用。zookeeper是cp，保证数据的一致性，nacos是有两种部署方式，既可以ap也可以cp</p>
<h5 id="base理论"><a href="#base理论" class="headerlink" title="base理论"></a>base理论</h5><ol>
<li>Basically Availiable(基本可用)：分布式系统在出现不可预知的故障时，允许损失部分可用性</li>
<li>Soft state(软状态)：允许系统中数据存在中间状态，并认为中间状态是不会影响系统的整体可用性（允许系统中不能节点的数据副本之间进行数据同步的过程存在延时）</li>
<li>Eventually Consitent(最终一致性)：系统中的所有数据副本经过一段时间后，最终能达到一致性的状态。（非实时一致性）</li>
</ol>
<p>核心思想：既然无法做到强一致性，每个应用可根据自己的业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p>springboot的start怎么写，facotry.properties干啥的</p>
<p>为啥mybatis接入spring后，一级缓存要失效，谈谈mybatis的缓存</p>
<p>springcloud全家桶说一下</p>
<h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>指的是用户查询的数据在数据库中本来就没有，当然在缓存中也就没有了，这样用户的查询每次都会进到数据库中。</p>
<p>解决办法：</p>
<ol>
<li>布隆过滤器，实现一个bitmap对key进行hash预算得到hashcode，然后将hashcode之后的放入到bitmap中去，如果一个key的hashcode的一部分没有在这个bitmap中，那这个值就一定不存在。</li>
<li>数据库中没有数据的话，就返回一个空对象放入到缓存中。</li>
</ol>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>在一个时间段内，大量缓存失效，本来应该访问缓存的请求都到数据库中去了，原因是设置的过期时间过于集中。</p>
<p>解决办法：</p>
<ol>
<li>设置过期时间的时候加个随机值，不至于大量缓存都在同一时间失效。</li>
</ol>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>高并发访问的情况下，热点缓存失效</p>
<p>解决办法</p>
<ol>
<li>采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有</li>
</ol>
<h5 id="缓存双写一致性："><a href="#缓存双写一致性：" class="headerlink" title="缓存双写一致性："></a>缓存双写一致性：</h5><p>缓存更新策略：</p>
<ol>
<li><p>先更新数据库，在更新缓存</p>
</li>
<li><p>先删除缓存，在更新数据库</p>
</li>
<li><p>先更新数据库，在删除缓存（双删除）</p>
</li>
</ol>
<p>写多读少，用缓存会带来额外的性能问题</p>
<h5 id="redis持久化规则"><a href="#redis持久化规则" class="headerlink" title="redis持久化规则"></a>redis持久化规则</h5><ol>
<li>RDB：在指定的时间间隔能对你的数据进行快照存储。（rdb方式是默认的持久化方式）</li>
<li>AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li>
</ol>
<h6 id="RDB相关："><a href="#RDB相关：" class="headerlink" title="RDB相关："></a>RDB相关：</h6><p>触发rdb的方式有如下几种：</p>
<ol>
<li>配置文件中的save 100 1 #100s内有一次写入就触发，可以定制多个规则进行触发</li>
<li>手动触发，save或者是bgsave,需要注意的是save会在主进程上执行快照功能，会带来阻塞，生产上慎用，bgsave是fork一个子进程来创建rdb文件，父进程可以继续处理请求，（bgsave也会阻塞，仅在fork时阻塞）</li>
</ol>
<p>rdb原理：</p>
<p>在自动触发快照时redis会fork出一个子进程来将内存中的所有数据写入到一个临时文件，写完后会用这个临时文件替换到已有的rdb文件，redis重启时会自动加载rdb文件进行恢复，并没有提供一个专门用于恢复rdb的命令。</p>
<p>额外项：</p>
<ol>
<li>rdb支持压缩</li>
<li>支持导入时检查</li>
<li>stop-writes-on-bgsave-error yes这个配置是默认开启的，如果在写入rdb时出错了，主进程会停止接受写入服务，这个是为了显示的让用户感知到redis出错了，从而保证数据的一致性</li>
</ol>
<p>优势：</p>
<ol>
<li>适合大规模数据的恢复，相对于aof来说，启动时恢复速度较快</li>
<li>保证redis的可用性，通过fork一个子进程来持久化，主进程一样的可以接受请求</li>
</ol>
<p>劣势：</p>
<ol>
<li>如果服务器突然宕机，还未来得及备份的数据会丢失，对数据完整性要求高的场景不推荐使用。</li>
<li>由于fork出一个进程处理，会使用额外的内存，性能有所影响，这里配置的时候应该需要注意限制一些redis主进程所使用的内存，留足够fork出来的子进程进行写快照所需的内存。</li>
</ol>
<h6 id="AOF相关："><a href="#AOF相关：" class="headerlink" title="AOF相关："></a>AOF相关：</h6><p>aof提供了一种更为可靠的持久化方式，当redis收到修改数据的命令是，会将命令追加到aof文件里面，在Redis重启时，会去执行aof文件内的命令，从而达到数据恢复的目的。</p>
<p>配置选项：</p>
<ol>
<li>appendonly：yes|no 是否开启aof默认关闭</li>
<li>appendfilename：文件名字</li>
<li>appendfsync：调用fsync()，将缓存（buffer）中的数据刷新到硬盘上去三个可选项：<ol>
<li>no不干预，让系统自己决定啥时候刷盘，性能影响最小</li>
<li>always写一次刷一次，影响性能，数据一致性最好</li>
<li>everysec默认选项，一秒刷一次，折中的选择</li>
</ol>
</li>
<li>no-appendfsync-on-rewrite：yes|no在重写时，是否调用fsync()</li>
<li>auto-aof-rewrite-percentage：设置超过之前aof文件大小的百分比，超过就有机会触发重写</li>
<li>auto-aof-rewrite-min-size：设置最小重写大小，为了避免本来aof文件就很小的情况下，重写aof</li>
<li>aof-load-truncated：yes|no 如果加装过程中发现aof文件有问题，是否继续加装还是报错</li>
<li>aof-use-rdb-preamble：Redis4.0的特性，RDB-AOF混合持久化</li>
</ol>
<h6 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h6><p>根据项目的需求来定，如果对性能要求高，但是对数据的丢失不太敏感，则可以选择rdb,如果对数据有一致性要求较高，尽量保证数据不丢失，则可以选择aof</p>
<h6 id="如何配置："><a href="#如何配置：" class="headerlink" title="如何配置："></a>如何配置：</h6><ol>
<li>rdb情况下，兼顾性能和数据一致性的情况下，可以多配置save points这样可以尽量的提高数据的可用性</li>
<li>aof情况下，按默认配置就行了</li>
</ol>
<h5 id="Redis淘汰机制"><a href="#Redis淘汰机制" class="headerlink" title="Redis淘汰机制"></a>Redis淘汰机制</h5><h6 id="why"><a href="#why" class="headerlink" title="why"></a>why</h6><p>当Redis内存超出物理限制时，会开始使用swap分区，导致性能下降，在生产中肯定是不能出现用swap的情况，则会设置最大使用内存的限制通过配置文件：maxmemory设置</p>
<p>如果超出了maxmemory的限制，则会走淘汰策略</p>
<h6 id="淘汰策略：（redis6-0）"><a href="#淘汰策略：（redis6-0）" class="headerlink" title="淘汰策略：（redis6.0）"></a>淘汰策略：（redis6.0）</h6><p>总结记忆就是lru,lfu,random,ttl,noeviction</p>
<ol>
<li>volatile-lru -&gt; 有过期时间的key参与到lru淘汰中</li>
<li>allkeys-lru -&gt; 所有key参与到lru淘汰</li>
<li>volatile-lfu -&gt;有过期时间的key参与到lfu淘汰中</li>
<li>allkeys-lfu -&gt;所有的key参与到lfu淘汰中</li>
<li>volatile-random -&gt; 有过期时间的key参与到随机淘汰</li>
<li>allkeys-random -&gt; 所有key参与到随机淘汰</li>
<li>volatile-ttl -&gt; 有过期时间的key过期时间越短越先淘汰</li>
<li>noeviction -&gt; 默认处理，不淘汰数据，只是不接受写入请求了并报错，不影响读请求</li>
</ol>
<h6 id="lRU算法"><a href="#lRU算法" class="headerlink" title="lRU算法"></a>lRU算法</h6><p>LRU(Least Recently Used)：最近不使用，认为如果一个数据最近一段时间很使用到，拿将来被使用的概率也较低，所有就可以被淘汰。</p>
<p>实现方式是有一个链表来实现，最近访问过去放到链表头部，需要淘汰时，淘汰链表尾部的节点</p>
<p>redis中使用的是近似LRU，因为LRU需要额外的大量的内存，近似LRU是通过随机采样（每次5个），在针对这些样本进行LRU，如果做了LRU内存还是不够用，就在做一次，以此类推</p>
<h6 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h6><p>LFU(Least Frequently Used):最近最少使用，认为一个数据在一段时间内被使用的次数少，那将来使用的概率也较小，所以可以被淘汰。</p>
<p>redis也是采用的近似LFU，大致同上</p>
<h5 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h5><p> redis分布式锁的实现是依赖于setnx这个api来实现的，当值不存在的时候就设置成功，设置成功的线程即为拿到锁的线程</p>
<p>主要考虑的问题：</p>
<ol>
<li><p>setnx之后，如果线程挂了，并没有释放锁，出现死锁的状态（过期时间解决）</p>
</li>
<li><p>误解锁：如一个线程a拿到锁之后执行时间过长，已经超过了锁的过期时间，这个时候锁就已经释放了，此时线程b进来拿到锁执行业务代码，线程a现在执行加锁的逻辑完了，释放了锁，此时线程c就可以进来了。<strong>解决办法，在设置锁的时候在锁对应的值是一个随机数，这个随机数只有加锁的线程知道，则可以避免线程把不属于自己的锁释放掉。</strong></p>
<ol>
<li><p>上诉解决办法中又会暴露出一个问题，判断锁中随机数和删除这个锁的动作不是原子性操作，则可能会出现，线程a判断了是自己的随机数，还没有来得及删除锁，锁已经过期了，此时线程b进来重新加锁了，线程a继续执行就把线程b的锁释放了。</p>
<p><strong>解决办法</strong>：通过lua脚本来保证原子性<code>&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;</code>**</p>
</li>
</ol>
</li>
<li><p>超时问题：如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。</p>
<p><strong>解决办法：</strong>1.设置足够长的超时时间保证执行完毕。2.为获取到锁的线程添加一个守护进程，用于做过期时间的续约。</p>
</li>
<li><p>可重入性问题</p>
<p><strong>解决方案：</strong>参考ReentantLock的实现，在加锁是记录+1，释放锁时，记录-1，值为0时删除锁。**可以通过TheadLocal来实现</p>
</li>
<li><p>等待获取锁，如果要获取的锁在被持有的状态，则可以等到持有锁的线程释放。</p>
<p><strong>解决办法：</strong>1.自旋锁。2.利用redis订阅的功能，没有获取到锁就订阅释放信息，锁释放后发送释放信息。</p>
</li>
</ol>
<h5 id="redis主从同步"><a href="#redis主从同步" class="headerlink" title="redis主从同步"></a>redis主从同步</h5><p>redis主从也是存在cap定理的问题，redis值ap尽量保证可用性，努力做到最终一致性。</p>
<h6 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h6><p>redis的主从同步是异步的，所以Redis不能满足<strong>一致性</strong>，当客户端在Redis主节点上写入了数据，立即返回了，即使现在的主从网络是断开了，主节点依然可以对外提供服务，所以满足了<strong>可用性</strong>，Redis的从节点会努力追赶主节点，如果主从的网络断开了，会导致主节点和从节点的数据不一致，在网络恢复后，从节点会努力追赶上主节点，实现数据的<strong>最终一致性</strong>。</p>
<h6 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h6><p>增量同步：</p>
<p>​    增量同步同步的是指令流（类似于aof），会将指令记在内存的buffer中，然后一步的将buffer中的指令同步到从节点，从节点一边执行同步过来的指令，一边向主节点返回自己同步到哪里了（偏移量）</p>
<p>​    内存的buffer是有限的，如果buffer填充满了，就会从头开始覆盖前面的内容，这回导致数据的不一致</p>
<p>快照同步：</p>
<p>​    在2.8.18（老掉牙的版本）前快照同步相当于执行了bgsave命令，在生成了rdb文件之后再传送给从节点，从节点在进行恢复，从节点进行恢复前会清空内存中数据，重新恢复一次，在快照同步的过程中，主节点的增量同步的buffer还是在不停的向前走，如果由于buffer太小，或者同步时间过长，会导致buffer中的指令被覆盖，这样会使得快照同步完成后无法进行增量同步，然后会在一次发起快照同步，如此会导致死循环。<strong>设置合适的buffer很重要</strong>。在2.8.18后支持了无盘复制，不需要写入硬盘，之间通过套接字传送给从节点。</p>
<h6 id="Wait指令"><a href="#Wait指令" class="headerlink" title="Wait指令"></a>Wait指令</h6><p>​    Redis的复制是异步的，但是可以通过wait让异步变为同步的，（3.0）以后才有的。</p>
<p>​    wait参数有两个，第一个是从库的数量，第二个是时间，毫秒为单位，时间参数为0是表示等到所有的从库复制完成，Redis在可以用。</p>
<h5 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h5><p>解决的问题：监控主节点状态，如果主节点挂了，立即冲从节点中找一个健康的作为新的主节点</p>
<p>客户端链接集群是会先链接到哨兵上，通过哨兵来查询主节点的地址，在链接主节点。当主节点发生错误是，客户端会重新想哨兵要一个新的主节点的地址。</p>
<p>如果集群中主节点挂了，原先的主从复制断开，客户端链接也断开，从节点被提升为主节点，其他从节点链接到新的主节点上建立复制，客户端会链接到新的主节点进行交互。</p>
<p>哨兵会一直监控原来挂掉的主节点，等主节点恢复后会将原来的主节点当做一个从节点放入到集群中</p>
<p>消息丢失：Redis非复制是异步的，这意味着如果主节点挂了从节点可能没有完全同步主节点的数据，哨兵没法保证数据不丢失，只能<strong>尽量保证少丢失</strong>，通过如下方式解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1 </span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>第一个参数表示集群中只是要有几个从节点可以正常的和主节点进行正常的复制</p>
<p>第二个参数用来判断什么算正常的复制，它的单位是秒，如果超过指定的时间都没有送到从节点的反馈，表明从节点同步不正常了</p>
<p>如果达到上说两个条件，则祝姐姐就停止对外的写服务，失去可用性。</p>
<h4 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h4><h5 id="服务降级用hystrix的话，原理，滑动窗口，参数配置"><a href="#服务降级用hystrix的话，原理，滑动窗口，参数配置" class="headerlink" title="服务降级用hystrix的话，原理，滑动窗口，参数配置"></a>服务降级用hystrix的话，原理，滑动窗口，参数配置</h5><p>hystrix中关键的配置为：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">circuitBreaker:</span></span><br><span class="line">	<span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启断路器</span></span><br><span class="line">	<span class="attr">requestVolumeThreshold:</span> <span class="number">20</span>  <span class="comment">#统计的阈值，超过了才统计</span></span><br><span class="line">	<span class="attr">sleepWindowInMilliseconds:</span> <span class="number">5000</span> <span class="comment">#熔断后睡眠时间</span></span><br><span class="line">	<span class="attr">errorThresholdPercentage:</span> <span class="number">50</span> <span class="comment">#错误率</span></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line">	<span class="attr">rollingStats:</span></span><br><span class="line">		<span class="attr">timeInMilliseconds:</span> <span class="number">10000</span> <span class="comment">#统计时间</span></span><br></pre></td></tr></table></figure>

<h5 id="eureka自我保护机制"><a href="#eureka自我保护机制" class="headerlink" title="eureka自我保护机制"></a>eureka自我保护机制</h5><p>默认状态下，15分钟内，85%的客户端都没有正常的心跳情况下，eureka会开启自我保护机制，目的是为了让eureka的集群更加健壮</p>
<p>在自我保护机制下，会出现以下的情况：</p>
<ol>
<li>Eureka不在自动下线没有收到心跳的过期服务</li>
<li>eureka会继续接受主从和查询，但是不会同步到其他节点，保证当前节点的可用</li>
<li>当网络稳定是，当前eureka会将新的注册信息同步到其他节点</li>
</ol>
<h6 id="eureka缓存"><a href="#eureka缓存" class="headerlink" title="eureka缓存"></a>eureka缓存</h6><ol>
<li>读写缓存：每次有服务实例状态变化（如注册服务、下线等）只会更新读写缓存</li>
<li>只读缓存永不过期，但是可能存在过期数据。此时为了保证只读数据的准确性，会有个定时器定时同步两个缓存，然后将状态变化的服务实例添加到”最近租约变更记录队列”。执行频率默认30s</li>
</ol>
<h5 id="ribbon均衡负载"><a href="#ribbon均衡负载" class="headerlink" title="ribbon均衡负载"></a>ribbon均衡负载</h5><ol>
<li>BestAvailableRule（最大可用）：选择一个最小的并发请求的server</li>
<li>AvailabilityFilteringRule（过滤繁忙）：过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</li>
<li>WeightedResponseTimeRule（加权响应时间）：根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。</li>
<li>RetryRule（重试）：对选定的负载均衡策略机上重试机制</li>
<li>RoundRobinRule（轮训[默认]）：以roundRobin方式轮询选择server</li>
<li>RandomRule（随机）:随机选择一个server</li>
<li>ZoneAvoidanceRule：复合判断server所在区域的性能和server的可用性选择server</li>
</ol>
<h5 id="流量激增处理方式："><a href="#流量激增处理方式：" class="headerlink" title="流量激增处理方式："></a>流量激增处理方式：</h5><ol>
<li><p>缓存</p>
<p>用内存来顶替一部分db的查询，大概有3类：浏览器缓存，cdn缓存，服务器业务缓存</p>
</li>
<li><p>服务降级</p>
<p>展示降低非关键业务的资源，将资源划分给关键性服务，丢车保帅</p>
</li>
<li><p>限流</p>
<p>常用的算法有：1计数器 2滑动窗口 3滴漏 4令牌桶</p>
</li>
</ol>
<h5 id="eureka配置相关"><a href="#eureka配置相关" class="headerlink" title="eureka配置相关"></a>eureka配置相关</h5><h4 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h4><h5 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h5><ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h5 id="新建代码仓库"><a href="#新建代码仓库" class="headerlink" title="新建代码仓库"></a>新建代码仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure>

<h5 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h5 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h5 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h5 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/20/mysql%E7%AC%94%E8%AE%B0/" rel="prev" title="mysql笔记">
                mysql笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tom</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#java基础"><span class="nav-number">1.</span> <span class="nav-text">java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#基础数据类型"><span class="nav-number">1.0.1.</span> <span class="nav-text">基础数据类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#String-Stringbuffer-Stringbuilder区别："><span class="nav-number">1.0.2.</span> <span class="nav-text">String,Stringbuffer,Stringbuilder区别：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><span class="nav-number">1.0.3.</span> <span class="nav-text">讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><span class="nav-number">1.0.4.</span> <span class="nav-text">抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象基础"><span class="nav-number">2.</span> <span class="nav-text">面向对象基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java集合"><span class="nav-number">3.</span> <span class="nav-text">java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈谈你对java集合的理解"><span class="nav-number">3.1.</span> <span class="nav-text">请谈谈你对java集合的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈下arraylist和Linkedlist的区别"><span class="nav-number">3.2.</span> <span class="nav-text">请谈下arraylist和Linkedlist的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈下arraylist的扩容机制"><span class="nav-number">3.3.</span> <span class="nav-text">请谈下arraylist的扩容机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈下hashmap"><span class="nav-number">3.4.</span> <span class="nav-text">请谈下hashmap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Hashmap在jdk1-8中的resize不需要重新hash原因"><span class="nav-number">3.4.1.</span> <span class="nav-text">Hashmap在jdk1.8中的resize不需要重新hash原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#插入流程："><span class="nav-number">3.4.2.</span> <span class="nav-text">插入流程：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#resize方法具体是咋样的"><span class="nav-number">3.4.3.</span> <span class="nav-text">resize方法具体是咋样的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#常见问题"><span class="nav-number">3.4.4.</span> <span class="nav-text">常见问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程"><span class="nav-number">4.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈下线程和进程的区别"><span class="nav-number">4.1.</span> <span class="nav-text">请谈下线程和进程的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈下java线程的几种状态"><span class="nav-number">4.2.</span> <span class="nav-text">请谈下java线程的几种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈下java锁升级的过程"><span class="nav-number">4.3.</span> <span class="nav-text">请谈下java锁升级的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#升级过程："><span class="nav-number">4.3.1.</span> <span class="nav-text">升级过程：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请谈谈你对volatile的理解"><span class="nav-number">4.4.</span> <span class="nav-text">请谈谈你对volatile的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lock解决了哪些synchronized不能解决的问题"><span class="nav-number">4.5.</span> <span class="nav-text">lock解决了哪些synchronized不能解决的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程池"><span class="nav-number">4.6.</span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql"><span class="nav-number">5.</span> <span class="nav-text">mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#索引："><span class="nav-number">5.1.</span> <span class="nav-text">索引：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最左匹配原则"><span class="nav-number">5.2.</span> <span class="nav-text">最左匹配原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql优化"><span class="nav-number">5.3.</span> <span class="nav-text">sql优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#连接查询"><span class="nav-number">5.4.</span> <span class="nav-text">连接查询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring"><span class="nav-number">6.</span> <span class="nav-text">spring</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#spring-bean的生命周期"><span class="nav-number">6.1.</span> <span class="nav-text">spring bean的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ioc-aop讲一下"><span class="nav-number">6.2.</span> <span class="nav-text">ioc,aop讲一下</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring事务的传播性"><span class="nav-number">6.3.</span> <span class="nav-text">spring事务的传播性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三级缓存："><span class="nav-number">6.4.</span> <span class="nav-text">三级缓存：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mybatis"><span class="nav-number">7.</span> <span class="nav-text">Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#和-的区别"><span class="nav-number">7.1.</span> <span class="nav-text">#和$的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mybatis的缓存"><span class="nav-number">7.2.</span> <span class="nav-text">mybatis的缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mybatis实现分页的方式"><span class="nav-number">7.3.</span> <span class="nav-text">mybatis实现分页的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式事务"><span class="nav-number">8.</span> <span class="nav-text">分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cap定理"><span class="nav-number">8.1.</span> <span class="nav-text">cap定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#base理论"><span class="nav-number">8.2.</span> <span class="nav-text">base理论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis"><span class="nav-number">9.</span> <span class="nav-text">redis</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存穿透"><span class="nav-number">9.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">9.2.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存击穿"><span class="nav-number">9.3.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存双写一致性："><span class="nav-number">9.4.</span> <span class="nav-text">缓存双写一致性：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis持久化规则"><span class="nav-number">9.5.</span> <span class="nav-text">redis持久化规则</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#RDB相关："><span class="nav-number">9.5.1.</span> <span class="nav-text">RDB相关：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF相关："><span class="nav-number">9.5.2.</span> <span class="nav-text">AOF相关：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何选择："><span class="nav-number">9.5.3.</span> <span class="nav-text">如何选择：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何配置："><span class="nav-number">9.5.4.</span> <span class="nav-text">如何配置：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis淘汰机制"><span class="nav-number">9.6.</span> <span class="nav-text">Redis淘汰机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#why"><span class="nav-number">9.6.1.</span> <span class="nav-text">why</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#淘汰策略：（redis6-0）"><span class="nav-number">9.6.2.</span> <span class="nav-text">淘汰策略：（redis6.0）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#lRU算法"><span class="nav-number">9.6.3.</span> <span class="nav-text">lRU算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#LFU算法"><span class="nav-number">9.6.4.</span> <span class="nav-text">LFU算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis实现分布式锁"><span class="nav-number">9.7.</span> <span class="nav-text">redis实现分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis主从同步"><span class="nav-number">9.8.</span> <span class="nav-text">redis主从同步</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#最终一致性"><span class="nav-number">9.8.1.</span> <span class="nav-text">最终一致性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#同步方式"><span class="nav-number">9.8.2.</span> <span class="nav-text">同步方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Wait指令"><span class="nav-number">9.8.3.</span> <span class="nav-text">Wait指令</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哨兵模式"><span class="nav-number">9.9.</span> <span class="nav-text">哨兵模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-cloud"><span class="nav-number">10.</span> <span class="nav-text">spring cloud</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#服务降级用hystrix的话，原理，滑动窗口，参数配置"><span class="nav-number">10.1.</span> <span class="nav-text">服务降级用hystrix的话，原理，滑动窗口，参数配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eureka自我保护机制"><span class="nav-number">10.2.</span> <span class="nav-text">eureka自我保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#eureka缓存"><span class="nav-number">10.2.1.</span> <span class="nav-text">eureka缓存</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ribbon均衡负载"><span class="nav-number">10.3.</span> <span class="nav-text">ribbon均衡负载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流量激增处理方式："><span class="nav-number">10.4.</span> <span class="nav-text">流量激增处理方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eureka配置相关"><span class="nav-number">10.5.</span> <span class="nav-text">eureka配置相关</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git相关"><span class="nav-number">11.</span> <span class="nav-text">git相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#相关名词"><span class="nav-number">11.1.</span> <span class="nav-text">相关名词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#新建代码仓库"><span class="nav-number">11.2.</span> <span class="nav-text">新建代码仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#配置"><span class="nav-number">11.3.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、增加-删除文件"><span class="nav-number">11.4.</span> <span class="nav-text">三、增加&#x2F;删除文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码提交"><span class="nav-number">11.5.</span> <span class="nav-text">代码提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分支"><span class="nav-number">11.6.</span> <span class="nav-text">分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标签"><span class="nav-number">11.7.</span> <span class="nav-text">标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看信息"><span class="nav-number">11.8.</span> <span class="nav-text">查看信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#远程同步"><span class="nav-number">11.9.</span> <span class="nav-text">远程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#撤销"><span class="nav-number">11.10.</span> <span class="nav-text">撤销</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tom</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
